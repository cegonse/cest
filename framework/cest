#pragma once

#include <functional>
#include <iostream>
#include <sstream>
#include <string>
#include <cstdio>
#include <cstring>
#include <vector>

#define ASCII_RED               "\033[1m\033[31m"
#define ASCII_GREEN             "\033[1m\033[32m"
#define ASCII_RESET             "\033[0m"
#define TEST_NAME_LENGTH        4096
#define describe(x, y)          std::string test_suite_name = describe_function(x, y)
#define it(x, y)                it_function(__FILE__, x, y)
#define expect(x)               expect_function(__FILE__, __LINE__, x)

struct TestCase {
    char name[TEST_NAME_LENGTH];
    char file[TEST_NAME_LENGTH];
    std::function<void()> test;
};


std::vector<TestCase *> test_cases;
extern std::string test_suite_name;
std::function<void()> before_each;
std::function<void()> after_each;
bool test_failed;
std::stringstream assertion_failures;


std::string describe_function(std::string test_name, std::function<void()> test)
{
    test();
    return test_name;
}


void it_function(const char *file, char *name, std::function<void()> test)
{
    TestCase *test_case = new TestCase();
    
    strcpy(test_case->name, name);
    strcpy(test_case->file, file);
    test_case->test = test;

    test_cases.push_back(test_case);
}


void beforeEach(std::function<void()> func)
{
    before_each = func;
}


void afterEach(std::function<void()> func)
{
    after_each = func;
}


template<class T>
class Assertion
{
    public:
        Assertion(const char *file, int line, T value)
        {
            actual = value;
            assertion_file = std::string(file);
            assertion_line = line;
        }

        void toBe(T expected)
        {
            if (expected != actual) {
                test_failed = true;
                assertion_failures << ASCII_RED << "    âœ– Assertion Failed:" << ASCII_RESET << " Expected " << expected << ", was " << actual << std::endl;
                assertion_failures << "                        " << assertion_file << ":" << assertion_line << std::endl;
            }
        }

        void toEqualMemory(T expected, int64_t length)
        {
            int i;

            for (i=0; i<length; ++i) {
                if (expected[i] != actual[i]) {
                    test_failed = true;
                    assertion_failures << ASCII_RED << "    âœ– Assertion Failed:" << ASCII_RESET << " Memory mismatch at byte " << i << ", expected ";
                    assertion_failures << std::hex << std::uppercase << (int)expected[i] << " but was " << std::hex << std::uppercase << (int)actual[i] << std::endl;
                    assertion_failures << "                        " << assertion_file << ":" << assertion_line << std::endl;
                }
            }
        }

        void toBeNotNull()
        {
            if (actual == NULL) {
                test_failed = true;
                assertion_failures << ASCII_RED << "    âœ– Assertion Failed:" << ASCII_RESET << " Expected 0x";
                assertion_failures << std::hex << std::uppercase << actual << " to be not null" << std::endl;
                assertion_failures << "                        " << assertion_file << ":" << assertion_line << std::endl;
            }
        }

        void toBeNull()
        {
            if (actual != NULL) {
                test_failed = true;
                assertion_failures << ASCII_RED << "    âœ– Assertion Failed:" << ASCII_RESET << " Expected ";
                assertion_failures << std::hex << std::uppercase << actual << " to be null" << std::endl;
                assertion_failures << "                        " << assertion_file << ":" << assertion_line << std::endl;
            }
        }

    private:
        T actual;
        std::string assertion_file;
        int assertion_line;
};

template <>
class Assertion<std::string>
{
    public:
        Assertion(const char *file, int line, std::string value)
        {
            actual = value;
            assertion_file = std::string(file);
            assertion_line = line;
        }

        void toBe(std::string expected)
        {
            if (expected != actual) {
                test_failed = true;
                assertion_failures << ASCII_RED << "    âœ– Assertion Failed:" << ASCII_RESET << " Expected \"" << expected << "\", was \"" << actual << "\"" << std::endl;
                assertion_failures << "                        " << assertion_file << ":" << assertion_line << std::endl;
            }
        }

        void toContain(std::string expected)
        {
            if (actual.find(expected) == std::string::npos) {
                test_failed = true;
                assertion_failures << ASCII_RED << "    âœ– Assertion Failed:" << ASCII_RESET << " \"" << expected << "\" not present inside \"" << actual << "\"" << std::endl;
                assertion_failures << "                        " << assertion_file << ":" << assertion_line << std::endl;
            }
        }

        void toHaveLength(int64_t length)
        {
            if (actual.length() != length) {
                test_failed = true;
                assertion_failures << ASCII_RED << "    âœ– Assertion Failed:" << ASCII_RESET << " Length of \"" << actual << "\" expected to be " << length << ", was " << actual.length() << std::endl;
                assertion_failures << "                        " << assertion_file << ":" << assertion_line << std::endl;
            }
        }

    private:
        std::string actual;
        std::string assertion_file;
        int assertion_line;
};


template<class T>
Assertion<T> expect_function(const char *file, int line, T actual)
{
    return Assertion<T>(file, line, actual);
}

Assertion<bool> expect_function(const char *file, int line, bool actual)
{
    return Assertion<bool>(file, line, actual);
}

Assertion<int64_t> expect_function(const char *file, int line, int64_t actual)
{
    return Assertion<int64_t>(file, line, actual);
}

Assertion<std::string> expect_function(const char *file, int line, std::string actual)
{
    return Assertion<std::string>(file, line, actual);
}

Assertion<std::string> expect_function(const char *file, int line, const char *actual)
{
    return Assertion<std::string>(file, line, (std::string)actual);
}


int main(void)
{
    std::cout << "ðŸ¡† " << test_suite_name << std::endl;

    for (TestCase *test_case : test_cases) {
        test_failed = false;

        if (before_each) {
            before_each();
        }

        test_case->test();

        if (after_each) {
            after_each();
        }

        std::cout << "  " << test_case->file << " ðŸ¡† it " << test_case->name << " ðŸ¡† ";

        if (test_failed) {
            std::cout << ASCII_RED << "FAIL" << ASCII_RESET << std::endl;
        } else {
            std::cout << ASCII_GREEN << "PASS" << ASCII_RESET << std::endl;
        }

        std::cout << assertion_failures.str();
        assertion_failures.str(std::string());

        delete test_case;
    }

    return 0;
}
